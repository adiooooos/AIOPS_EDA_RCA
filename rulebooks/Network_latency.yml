
#定位高负载进程
##执行 top -b -n 1 | head -n 20 获取系统负载快照和CPU占用最高的进程列表。
##执行 pidstat -u -p ALL 1 5 记录5秒内所有进程的CPU使用情况
#函数级性能剖析 (关键动作)
##触发一次perf recording
#打包与报告
##将 perf.data 文件、top、pidstat、strace 的输出结果传输到诊断服务器 /Diagnose/<目标机器名称-YYYY-MM-dd-hh-mm>目录下，
#top命令返回的结果和pidstat返回的结果存到一个文件里
# perf recording后的data文件单独执行perf report操作，并执行火焰图分析。

---
- name: "Linux Performance Analysis for High CPU Usage"
  hosts: rhel9
  become: true
  vars:
    perf_duration: 15
    output_base: "/TS"
    diagnose_server: "10.66.208.232"
    n8n_webhook_url: "http://n8n-server:5678/webhook/fault-diagnosis"
    # 创建精确的时间戳格式：YYYY-MM-dd-hh-mm
    timestamp_suffix: "{{ ansible_date_time.date }}-{{ ansible_date_time.hour }}-{{ ansible_date_time.minute }}"
  
  tasks:
    # ===========================================
    # 第一阶段：环境准备和工具检查
    # ===========================================
    # 检查系统是否已安装必要的性能分析工具
    # 如果缺少工具，自动安装perf、sysstat等包
    - name: "Check required tools availability"
      ansible.builtin.command: "which {{ item }}"
      loop: [perf, pidstat]
      register: tool_check
      ignore_errors: yes
      changed_when: false

    - name: "Install required packages if missing"
      ansible.builtin.dnf:
        name: 
          - perf
          - sysstat
          - kernel-debuginfo
          - kernel-debuginfo-common
        state: present
      when: tool_check.results | selectattr('rc', 'ne', 0) | list | length > 0
      register: package_install
      ignore_errors: yes

    # ===========================================
    # 第二阶段：系统性能数据收集
    # ===========================================
    # 创建带时间戳的输出目录，收集系统负载快照和CPU使用统计
    # 识别高CPU使用率的进程，为后续perf分析做准备
    - name: "Create timestamped output directory"
      ansible.builtin.file:
        path: "{{ output_base }}/{{ inventory_hostname }}-{{ timestamp_suffix }}"
        state: directory
        mode: '0755'
      register: output_dir

    - name: "Capture system load snapshot with top (limited to 30 lines)"
      ansible.builtin.shell: "top -b -n 1 | head -n 30"
      register: top_output
      changed_when: false

    - name: "Record CPU usage statistics with pidstat (sorted by CPU usage, limited to 30 lines)"
      ansible.builtin.shell: |
        pidstat -u -p ALL 1 5 | \
        awk 'NR<=3 || ($8 != "" && $8 != "0.00" && $8 != "CPU") {print}' | \
        sort -k8 -nr | \
        head -n 30
      register: pidstat_output
      changed_when: false

    - name: "Find processes with CPU usage greater than 90%"
      ansible.builtin.shell: |
        ps -eo pid,%cpu --sort=-%cpu | awk '$2 > 90 {print $1}'
      register: high_cpu_processes
      changed_when: false

    - name: "Fail if no processes with CPU usage greater than 90% found"
      ansible.builtin.fail:
        msg: "No process found with CPU usage > 90%"
      when: high_cpu_processes.stdout == ""

    - name: "Get the first process ID with high CPU usage"
      ansible.builtin.set_fact:
        pid: "{{ high_cpu_processes.stdout_lines[0] }}"

    - name: "Display target process info"
      ansible.builtin.debug:
        msg: "Targeting PID {{ pid }} for perf recording"

    # ===========================================
    # 第三阶段：perf性能分析数据收集
    # ===========================================
    # 将系统分析结果合并到单个文件，然后使用perf工具进行深度性能分析
    # perf record会记录指定进程的调用栈和性能数据，用于后续分析
    - name: "Combine top and pidstat output into single file"
      ansible.builtin.copy:
        content: |
          === TOP COMMAND OUTPUT  ===
          {{ top_output.stdout }}
          
          === PIDSTAT COMMAND OUTPUT (Sorted by CPU usage) ===
          {{ pidstat_output.stdout }}
          
          === TARGET PROCESS FOR PERF ===
          PID: {{ pid }}
        dest: "{{ output_dir.path }}/system_analysis.txt"
        mode: '0644'

    - name: "Record performance data using perf for the process (with debug symbols)"
      ansible.builtin.shell: |
        echo "Starting perf record for PID {{ pid }}"
        perf record -p {{ pid }} -a -g --call-graph dwarf -- sleep {{ perf_duration }} > {{ output_dir.path }}/perf_output.log 2>&1
      args:
        chdir: "{{ output_dir.path }}"
      register: perf_record_output
      ignore_errors: yes

    - name: "Verify perf.data creation"
      ansible.builtin.stat:
        path: "{{ output_dir.path }}/perf.data"
      register: perf_data_check

    - name: "Check for perf.data in other locations if not found"
      ansible.builtin.find:
        paths: "{{ output_dir.path }}"
        patterns: "perf.data*"
        recurse: yes
      register: perf_data_search
      when: not perf_data_check.stat.exists

    - name: "Display perf execution results and debugging info"
      ansible.builtin.debug:
        msg: |
          perf command execution details:
          - Return code: {{ perf_record_output.rc | default('N/A') }}
          - stdout: {{ perf_record_output.stdout | default('N/A') }}
          - stderr: {{ perf_record_output.stderr | default('N/A') }}
          - perf.data exists: {{ perf_data_check.stat.exists }}
          - perf.data search results: {{ perf_data_search.files | default([]) | map(attribute='path') | list }}
          - perf output log: {{ output_dir.path }}/perf_output.log

    - name: "Display collection summary"
      ansible.builtin.debug:
        msg: |
          Performance data collection completed:
          - Output directory: {{ output_dir.path }}
          - System analysis file: {{ output_dir.path }}/system_analysis.txt
          - perf.data created: {{ perf_data_check.stat.exists }}
          - perf.data size: {{ perf_data_check.stat.size | default('N/A') }} bytes
          - perf.data location: {{ output_dir.path }}/perf.data
          - perf output log: {{ output_dir.path }}/perf_output.log

    # ===========================================
    # 第四阶段：诊断服务器连接和目录准备
    # ===========================================
    # 设置诊断服务器路径，测试连接，创建目标目录
    # 确保SSH连接安全，避免主机密钥验证失败
    - name: "Set diagnose server variables"
      ansible.builtin.set_fact:
        diagnose_path: "/diagnose/{{ inventory_hostname }}-{{ timestamp_suffix }}"
        diagnose_full_path: "/diagnose/{{ inventory_hostname }}-{{ timestamp_suffix }}/"

    - name: "Test connection to Diagnose Server"
      ansible.builtin.ping:
      delegate_to: "{{ diagnose_server }}"
      register: diagnose_ping_result
      ignore_errors: yes

    - name: "Display diagnose server connection status"
      ansible.builtin.debug:
        msg: "Diagnose Server connection: {{ 'SUCCESS' if diagnose_ping_result is succeeded else 'FAILED' }}"

    - name: "Create diagnose directory on Diagnose Server"
      ansible.builtin.file:
        path: "{{ diagnose_path }}"
        state: directory
        mode: '0755'
        owner: root
        group: root
      delegate_to: "{{ diagnose_server }}"
      register: diagnose_dir_result
      ignore_errors: yes

    - name: "Display diagnose directory creation result"
      ansible.builtin.debug:
        msg: "Diagnose directory creation: {{ 'SUCCESS' if diagnose_dir_result is succeeded else 'FAILED' }} - {{ diagnose_dir_result.msg | default('No message') }}"

    - name: "Verify diagnose directory exists"
      ansible.builtin.stat:
        path: "{{ diagnose_path }}"
      delegate_to: "{{ diagnose_server }}"
      register: diagnose_dir_check
      ignore_errors: yes

    - name: "Display directory verification result"
      ansible.builtin.debug:
        msg: "Directory exists: {{ diagnose_dir_check.stat.exists | default(false) }}"

    - name: "Ensure diagnose server host key is in known_hosts (source host)"
      ansible.builtin.known_hosts:
        name: "{{ diagnose_server }}"
        key: "{{ lookup('pipe', 'ssh-keyscan -T 5 -H ' ~ diagnose_server) }}"
        path: "/root/.ssh/known_hosts"

    # ===========================================
    # 第五阶段：性能数据文件传输到诊断服务器
    # ===========================================
    # 验证源目录和文件，使用synchronize模块将收集的性能数据
    # 从故障节点传输到诊断服务器进行集中分析
    - name: "Verify source directory exists before transfer"
      ansible.builtin.stat:
        path: "{{ output_dir.path }}"
      register: source_dir_check

    - name: "Display source directory verification"
      ansible.builtin.debug:
        msg: |
          Source directory check:
          - Path: {{ output_dir.path }}
          - Exists: {{ source_dir_check.stat.exists }}
          - Is directory: {{ source_dir_check.stat.isdir | default(false) }}

    - name: "List source directory contents"
      ansible.builtin.find:
        paths: "{{ output_dir.path }}"
        patterns: "*"
        recurse: yes
      register: source_files

    - name: "Display source files"
      ansible.builtin.debug:
        msg: |
          Source files to transfer:
          {% for file in source_files.files | default([]) %}
          - {{ file.path }} ({{ file.size | default(0) }} bytes)
          {% endfor %}

    - name: "Verify source directory exists on fault node"
      ansible.builtin.command: "ls -ld {{ output_dir.path }}"
      register: verify_ts
      ignore_errors: yes

    - name: "Display directory verification result"
      ansible.builtin.debug:
        msg: |
          Directory verification on fault node:
          - Command: ls -ld {{ output_dir.path }}
          - Return code: {{ verify_ts.rc | default('N/A') }}
          - Output: {{ verify_ts.stdout | default('No output') }}
          - Error: {{ verify_ts.stderr | default('No error') }}

    - name: "Transfer collected files to Diagnose Server using synchronize (push)"
      ansible.posix.synchronize:
        src: "{{ output_dir.path }}/"
        dest: "root@{{ diagnose_server }}:{{ diagnose_full_path }}"
        recursive: yes
        mode: push
      delegate_to: "{{ inventory_hostname }}"
      register: sync_result
      ignore_errors: yes
      when: source_dir_check.stat.exists and source_dir_check.stat.isdir

    - name: "Display synchronize transfer result"
      ansible.builtin.debug:
        msg: |
          synchronize transfer result:
          - Status: {{ 'SUCCESS' if sync_result is succeeded else 'FAILED' }}
          - Rc: {{ sync_result.rc | default('N/A') }}
          - Stdout: {{ sync_result.stdout | default('') }}
          - Stderr: {{ sync_result.stderr | default('') }}

    - name: "Verify files were transferred successfully"
      ansible.builtin.find:
        paths: "{{ diagnose_path }}"
        patterns: "*"
        recurse: yes
      delegate_to: "{{ diagnose_server }}"
      register: transferred_files
      ignore_errors: yes

    - name: "Display transferred files"
      ansible.builtin.debug:
        msg: |
          Transferred files on Diagnose Server:
          {% for file in transferred_files.files | default([]) %}
          - {{ file.path }} ({{ file.size | default(0) }} bytes)
          {% endfor %}
      
    # ===========================================
    # 第六阶段：perf报告生成和分析
    # ===========================================
    # 在诊断服务器上使用perf report分析收集的性能数据
    # 生成可读的性能分析报告，清理原始数据文件
    - name: "Generate perf report on Diagnose Server"
      ansible.builtin.shell: |
        cd {{ diagnose_path }}
        perf report -g --stdio -i perf.data | head -100 > {{ inventory_hostname }}-{{ ansible_date_time.date }}_perf_01.txt
      args:
        executable: /bin/bash
      delegate_to: "{{ diagnose_server }}"
      register: perf_report_result
      ignore_errors: yes

    - name: "Display perf report generation result"
      ansible.builtin.debug:
        msg: |
          Perf report executed on Diagnose Server:
          - Command return code: {{ perf_report_result.rc | default('N/A') }}
          - Stdout: {{ perf_report_result.stdout | default('') }}
          - Stderr: {{ perf_report_result.stderr | default('') }}
          - Output file: {{ diagnose_path }}/{{ inventory_hostname }}-{{ ansible_date_time.date }}_perf_01.txt

    - name: "Check if perf report output file exists"
      ansible.builtin.stat:
        path: "{{ diagnose_path }}/{{ inventory_hostname }}-{{ ansible_date_time.date }}_perf_01.txt"
      delegate_to: "{{ diagnose_server }}"
      register: perf_report_file

    - name: "Remove original perf.data if report exists"
      ansible.builtin.file:
        path: "{{ diagnose_path }}/perf.data"
        state: absent
      delegate_to: "{{ diagnose_server }}"
      when: perf_report_file.stat.exists
      register: remove_perf_data

    - name: "Display perf.data cleanup result"
      ansible.builtin.debug:
        msg: |
          perf.data cleanup:
          - Report file exists: {{ perf_report_file.stat.exists }}
          - perf.data removed: {{ remove_perf_data is succeeded }}


    # ===========================================
    # 第七阶段：Alert信息文件处理
    # ===========================================
    # 查找/tmp/目录下该故障机器IP的alert信息文件，按时间排序获取最新文件
    # 将最新的alert文件传输到诊断服务器，与性能数据合并分析
    # 查找/tmp/目录下该故障机器IP的所有alert信息文件
    - name: "Find alert info files for this host IP"
      ansible.builtin.find:
        paths: "/tmp"
        patterns: "{{ inventory_hostname }}-*-alert_info.txt"
        recurse: no
      register: alert_files
 
    - name: "Display found alert files"
      ansible.builtin.debug:
        msg: |
          Found alert files:
          {% for file in alert_files.files %}
          - {{ file.path }} ({{ file.mtime }})
          {% endfor %}

    # 按修改时间排序，获取最新的alert文件
    - name: "Get the latest alert file"
      ansible.builtin.set_fact:
        latest_alert_file: "{{ alert_files.files | sort(attribute='mtime') | last }}"
      when: alert_files.files | length > 0

    - name: "Display latest alert file"
      ansible.builtin.debug:
        msg: "Latest alert file: {{ latest_alert_file.path }} ({{ latest_alert_file.mtime }})"
      when: latest_alert_file is defined

    # 将最新的alert文件传输到诊断服务器
    - name: "Transfer latest alert file to Diagnose Server"
      ansible.posix.synchronize:
        src: "{{ latest_alert_file.path }}"
        dest: "root@{{ diagnose_server }}:{{ diagnose_path }}/"
        mode: push
      delegate_to: "{{ inventory_hostname }}"
      register: alert_transfer_result
      ignore_errors: yes
      when: latest_alert_file is defined

    - name: "Display alert file transfer result"
      ansible.builtin.debug:
        msg: |
          Alert file transfer result:
          - Status: {{ 'SUCCESS' if alert_transfer_result is succeeded else 'FAILED' }}
          - Rc: {{ alert_transfer_result.rc | default('N/A') }}
          - Stdout: {{ alert_transfer_result.stdout | default('') }}
          - Stderr: {{ alert_transfer_result.stderr | default('') }}
          - Transferred file: {{ latest_alert_file.path | default('N/A') }}
      when: latest_alert_file is defined

    # 验证alert文件是否成功传输到诊断服务器
    - name: "Verify alert file was transferred successfully"
      ansible.builtin.stat:
        path: "{{ diagnose_path }}/{{ latest_alert_file.path | basename }}"
      delegate_to: "{{ diagnose_server }}"
      register: alert_file_check
      ignore_errors: yes
      when: latest_alert_file is defined
 
    - name: "Display alert file verification result"
      ansible.builtin.debug:
        msg: |
          Alert file verification:
          - File exists on diagnose server: {{ alert_file_check.stat.exists | default(false) }}
          - File size: {{ alert_file_check.stat.size | default('N/A') }} bytes
          - File path: {{ diagnose_path }}/{{ latest_alert_file.path | basename | default('N/A') }}
      when: latest_alert_file is defined


    # ===========================================
    # 第八阶段：文件合并和最终报告生成
    # ===========================================
    # 将所有诊断文件（alert信息、系统分析、perf报告等）合并为单一报告
    # 生成issues_latest.txt作为最终的故障诊断报告
    - name: "Merge all files into issues_latest.txt on Diagnose Server"
      ansible.builtin.shell: |
        cd {{ diagnose_path }}
        ALERT_FILE="{{ latest_alert_file.path | basename | default('') }}"

        if [ -n "$ALERT_FILE" ] && [ -f "$ALERT_FILE" ]; then
          echo "=== ALERT INFO ===" > issues_latest.txt
          cat "$ALERT_FILE" >> issues_latest.txt
          echo "" >> issues_latest.txt
          echo "=== OTHER DIAGNOSTIC FILES ===" >> issues_latest.txt
          echo "" >> issues_latest.txt
        else
          echo "=== DIAGNOSTIC FILES ===" > issues_latest.txt
          echo "" >> issues_latest.txt
        fi

        # 使用 find 保证健壮性，支持空格文件名
        find . -maxdepth 1 -type f \( -name "*.txt" -o -name "*.log" -o -name "*.data" \) \
          ! -name "issues_latest.txt" ! -name "$ALERT_FILE" -print0 |
        while IFS= read -r -d '' file; do
          echo "=== ${file#./} ===" >> issues_latest.txt
          cat "$file" >> issues_latest.txt
          echo "" >> issues_latest.txt
          echo "" >> issues_latest.txt
        done

        echo "Files merged into issues_latest.txt:"
        echo "Alert file used: $ALERT_FILE"
        ls -la issues_latest.txt
      args:
        executable: /bin/bash
      delegate_to: "{{ diagnose_server }}"
      register: merge_result
      ignore_errors: yes

    - name: "Display merge result"
      ansible.builtin.debug:
        msg: |
          File merge completed:
          - Return code: {{ merge_result.rc | default('N/A') }}
          - Stdout: {{ merge_result.stdout | default('') }}
          - Stderr: {{ merge_result.stderr | default('') }}
          - Merged file: {{ diagnose_path }}/issues_latest.txt

    - name: "Verify merged file exists"
      ansible.builtin.stat:
        path: "{{ diagnose_path }}/issues_latest.txt"
      delegate_to: "{{ diagnose_server }}"
      register: merged_file_stat

    - name: "Display merged file information"
      ansible.builtin.debug:
        msg: |
          Merged file verification:
          - File exists: {{ merged_file_stat.stat.exists }}
          - File size: {{ merged_file_stat.stat.size | default(0) }} bytes
          - File path: {{ diagnose_path }}/issues_latest.txt

    - name: "Notify Diagnose Server directory location"
      ansible.builtin.debug:
        msg: "Data transferred to Diagnose Server: {{ diagnose_path }}"
